#!/bin/bash

# Sends cascade of notifications at specified intervals before target time
#
# Requirements:
# - ./notify-at
# - ./notify
#
# Supports all notify-at time formats:
# - HH:MM, MM-DD HH:MM, YYYY-MM-DD HH:MM
#
# ```shell-session
# $ notify-cascade 15:00 "Meeting" "Team meeting starts" 1h 30m 10m 5m
# $ notify-cascade "01-15 09:00" "Meeting" "New year meeting" 1h 30m 10m
# $ notify-cascade "2027-01-15 09:00" "Event" "Future event" 1d 1h 30m /path/to/sound.wav
# ```
#
# See also `$ notify-cascade --help`

set -e

function show_help() {
  cat << 'EOF'
notify-cascade - Sends cascade of notifications at specified intervals before target time

Usage:
  notify-cascade TIME title message [timing1] [timing2] ... [sound]
  notify-cascade --help

Arguments:
  TIME      Target time in one of the supported formats
  title     Notification title
  message   Notification message
  timing    Intervals before target time (e.g., 1h, 30m, 5s)
  sound     Optional sound file (default: configured sound)

TIME formats (See also `$ notify-at --help`):
  HH:MM                - Time today (if past, then tomorrow)
  MM-DD HH:MM          - Month-day-time (must be future)
  YYYY-MM-DD HH:MM     - Year-month-day-time (must be future)

Timing formats:
  4h        4 hours before
  30m       30 minutes before
  45s       45 seconds before

Examples:
  notify-cascade 15:00 'Meeting' 'Team meeting starts' 1h 30m 10m 5m
  notify-cascade '01-15 09:00' 'Meeting' 'New year meeting' 1h 30m 10m
  notify-cascade '2027-01-15 09:00' 'Event' 'Future event' 1d 1h 30m /path/to/sound.wav
EOF
}

[[ $1 == --help ]] && show_help && exit 0

if [[ $# -lt 3 ]] ; then
  show_help
  exit 1
fi

time="$1"
title="$2"
message="$3"

# Parse timing arguments and potential sound file
timings=()
sound=""

for i in $(seq 4 $#) ; do
  arg="${!i}"

  # Check if argument looks like a timing (contains h, m, or s)
  if [[ "$arg" =~ ^[0-9]+[hms]$ ]] ; then
    timings+=("$arg")
  else
    # Assume it's a sound file if it doesn't match timing pattern
    sound="$arg"
    break
  fi
done

# Use default sound if not specified
if [[ $sound == '' ]] ; then
  sound="${BASH_TOYS_NOTIFY_CASCADE_DEFAULT_SOUND:-${BASH_TOYS_NOTIFY_AT_DEFAULT_SOUND:-default}}"
fi

# Function to convert timing to seconds
function timing_to_seconds() {
  local timing="$1"
  local number="${timing%?}"
  local unit="${timing: -1}"

  case "$unit" in
    h) echo $((number * 3600)) ;;
    m) echo $((number * 60)) ;;
    s) echo "$number" ;;
    *) echo "0" ;;
  esac
}

# Date format functions (shared with notify-at)
# Format detection function
function detect_time_format() {
  local time_input="$1"

  if [[ $time_input =~ ^[0-9]{4}-[0-9]{2}-[0-9]{2}[[:space:]][0-9]{2}:[0-9]{2}$ ]] ; then
    echo "YYYY-MM-DD HH:MM"
  elif [[ $time_input =~ ^[0-9]{2}-[0-9]{2}[[:space:]][0-9]{2}:[0-9]{2}$ ]] ; then
    echo "MM-DD HH:MM"
  elif [[ $time_input =~ ^[0-9]{2}:[0-9]{2}$ ]] ; then
    echo "HH:MM"
  else
    echo "INVALID"
  fi
}

# Date normalization function
function normalize_datetime() {
  local time_input="$1"
  local format="$2"
  local current_year
  current_year=$(date +%Y)

  case "$format" in
    "HH:MM")
      echo "$(date +%Y-%m-%d) $time_input"
      ;;
    "MM-DD HH:MM")
      echo "$current_year-$time_input"
      ;;
    "YYYY-MM-DD HH:MM")
      echo "$time_input"
      ;;
  esac
}

# Past date validation function
function validate_future_datetime() {
  local normalized_datetime="$1"
  local original_format="$2"
  local current_timestamp
  current_timestamp=$(date +%s)
  local target_timestamp

  # Only validate future dates for new formats
  if [[ "$original_format" != "HH:MM" ]] ; then
    if date --version &> /dev/null ; then
      target_timestamp=$(date -d "$normalized_datetime" +%s 2>/dev/null || return 1)
    else
      target_timestamp=$(date -j -f "%Y-%m-%d %H:%M" "$normalized_datetime" +%s 2>/dev/null || return 1)
    fi

    if [[ $target_timestamp -le $current_timestamp ]] ; then
      echo "Error: Specified date/time is in the past: $normalized_datetime" >&2
      return 1
    fi
  fi

  return 0
}

# Calculate target time using new format support
now=$(date +%s)

format=$(detect_time_format "$time")
if [[ $format == "INVALID" ]] ; then
  echo "Error: Invalid time format. Use HH:MM, MM-DD HH:MM, or YYYY-MM-DD HH:MM"
  exit 1
fi

normalized_datetime=$(normalize_datetime "$time" "$format")
if ! validate_future_datetime "$normalized_datetime" "$format" ; then
  exit 1
fi

# Unified date parsing for both GNU and BSD
if date --version >/dev/null 2>&1 ; then
  if ! target=$(date -d "$normalized_datetime" +%s 2>/dev/null) ; then
    echo "Error: Invalid date/time format"
    exit 1
  fi
else
  if ! target=$(date -j -f "%Y-%m-%d %H:%M" "$normalized_datetime" +%s 2>/dev/null) ; then
    echo "Error: Invalid date/time format"
    exit 1
  fi
fi

# Only add 24 hours for HH:MM format when time is in the past
if [[ $format == "HH:MM" && $target -le $now ]] ; then
  target=$((target + 86400))
fi

echo "Cascade notifications scheduled for: $time"
echo "Title: $title"
echo "Message: $message"
echo ""


# If no timings specified, show single notification at target time
if [[ ${#timings[@]} -eq 0 ]] ; then
  seconds=$((target - now))
  minutes=$((seconds / 60))
  echo "Single notification: $minutes minutes later"

  notify-at "$time" "$title" "$message" "$sound" &

  echo "Process ID: $!"
  exit 0
fi

# Schedule notifications for each timing
pids=()
for timing in "${timings[@]}" ; do
  offset_seconds=$(timing_to_seconds "$timing")
  notification_time=$((target - offset_seconds))

  # Skip if notification time is in the past
  if [[ $notification_time -le $now ]] ; then
    echo "Skipping $timing notification (time already passed)"
    continue
  fi

  sleep_seconds=$((notification_time - now))
  minutes=$((sleep_seconds / 60))

  # Create timing-specific message
  timing_message="$message ($timing before)"

  echo "$timing notification: in $minutes minutes"

  # Calculate the absolute time for this notification
  notification_hour=$(date -d "@$notification_time" +"%H:%M" 2>/dev/null || date -r "$notification_time" +"%H:%M")

  (
    notify-at "$notification_hour" "$title" "$timing_message" "$sound"
  ) &

  pids+=($!)
done

echo ""
echo "Process IDs: ${pids[*]}"

# https://github.com/aiya000/bash-toys
#
# The MIT License (MIT)
#
# Copyright (c) 2025- aiya000
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
