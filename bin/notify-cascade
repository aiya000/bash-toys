#!/bin/bash

# Sends cascade of notifications at specified intervals before target time
#
# Requirements:
# - ./notify-at
# - ./notify
#
# Supports all notify-at time formats:
# - HH:MM, MM-DD HH:MM, YYYY-MM-DD HH:MM
#
# ```shell-session
# $ notify-cascade 15:00 "Meeting" "Team meeting starts" 1h 30m 10m 5m
# $ notify-cascade "01-15 09:00" "Meeting" "New year meeting" 1h 30m 10m
# $ notify-cascade "2027-01-15 09:00" "Event" "Future event" 1d 1h 30m /path/to/sound.wav
# $ notify-cascade 15:00 "Meeting" "Team meeting starts" 1h 30m --mobile
# $ notify-cascade 15:00 "Meeting" "Team meeting starts" 1h 30m --mobile --local
# ```
#
# See also `$ notify-cascade --help`

set -e

function show_help() {
  cat << 'EOF'
notify-cascade - Sends cascade of notifications at specified intervals before target time

Usage:
  notify-cascade [options] TIME title message [timing1] [timing2] ... [sound]
  notify-cascade --help

Arguments:
  TIME      Target time in one of the supported formats
  title     Notification title
  message   Notification message
  timing    Intervals before target time (e.g., 1h, 30m, 5s)
  sound     Optional sound file (default: configured sound)

Options:
  --mobile    Send notifications to mobile via ntfy.sh
  --local     Send notifications to local desktop (default if no options specified)
  --help      Show this help message

Note: Options can be placed anywhere in the argument list.
      If --mobile is specified without --local, only mobile notifications are sent.
      If neither is specified, --local is assumed.

TIME formats (See also `$ notify-at --help`):
  HH:MM                - Time today (if past, then tomorrow)
  MM-DD HH:MM          - Month-day-time (must be future)
  YYYY-MM-DD HH:MM     - Year-month-day-time (must be future)

Timing formats:
  now       Send notification immediately
  4h        4 hours before
  30m       30 minutes before
  45s       45 seconds before

Environment Variables:
  BASH_TOYS_NTFY_TOPIC    Required when using --mobile. Your ntfy.sh topic name.

Examples:
  notify-cascade 15:00 'Meeting' 'Team meeting starts' 1h 30m 10m 5m
  notify-cascade '01-15 09:00' 'Meeting' 'New year meeting' 1h 30m 10m
  notify-cascade '2027-01-15 09:00' 'Event' 'Future event' 1d 1h 30m /path/to/sound.wav
  notify-cascade 15:00 'Meeting' 'Team meeting' 1h 30m --mobile
  notify-cascade 15:00 'Meeting' 'Team meeting' 1h 30m --mobile --local
  notify-cascade 15:00 'Meeting' 'Team meeting' now 1h 30m --local   # Immediate + scheduled
EOF
}

[[ $1 == --help ]] && show_help && exit 0

# Parse arguments - extract --mobile and --local options first
mobile_mode=false
local_mode=false
positional_args=()

for arg in "$@" ; do
  case "$arg" in
    --mobile)
      mobile_mode=true
      ;;
    --local)
      local_mode=true
      ;;
    *)
      positional_args+=("$arg")
      ;;
  esac
done

# Build notify-at options to pass through
notify_at_options=()
if [[ "$mobile_mode" == true ]] ; then
  notify_at_options+=("--mobile")
fi
if [[ "$local_mode" == true ]] ; then
  notify_at_options+=("--local")
fi

# Validate ntfy topic when mobile mode is requested
if [[ "$mobile_mode" == true && -z "${BASH_TOYS_NTFY_TOPIC:-}" ]] ; then
  echo "Error: BASH_TOYS_NTFY_TOPIC environment variable is required for --mobile option" >&2
  exit 1
fi

if [[ ${#positional_args[@]} -lt 3 ]] ; then
  show_help
  exit 1
fi

time="${positional_args[0]}"
title="${positional_args[1]}"
message="${positional_args[2]}"

# Parse timing arguments and potential sound file
timings=()
sound=""
send_now=false

for i in $(seq 3 $((${#positional_args[@]} - 1))) ; do
  arg="${positional_args[$i]}"

  # Check if argument is 'now' for immediate notification
  if [[ "$arg" == "now" ]] ; then
    send_now=true
  # Check if argument looks like a timing (contains h, m, or s)
  elif [[ "$arg" =~ ^[0-9]+[hms]$ ]] ; then
    timings+=("$arg")
  else
    # Assume it's a sound file if it doesn't match timing pattern
    sound="$arg"
    break
  fi
done

# Use default sound if not specified
if [[ $sound == '' ]] ; then
  sound="${BASH_TOYS_NOTIFY_CASCADE_DEFAULT_SOUND:-${BASH_TOYS_NOTIFY_AT_DEFAULT_SOUND:-default}}"
fi

# Format seconds to human-readable duration
# e.g., "1 day 2 hours 30 minutes later"
function format_duration() {
  local total_seconds="$1"
  local parts=()

  local days=$((total_seconds / 86400))
  local remaining=$((total_seconds % 86400))
  local hours=$((remaining / 3600))
  remaining=$((remaining % 3600))
  local minutes=$((remaining / 60))

  if [[ $days -gt 0 ]] ; then
    if [[ $days -eq 1 ]] ; then
      parts+=("1 day")
    else
      parts+=("$days days")
    fi
  fi

  if [[ $hours -gt 0 ]] ; then
    if [[ $hours -eq 1 ]] ; then
      parts+=("1 hour")
    else
      parts+=("$hours hours")
    fi
  fi

  if [[ $minutes -gt 0 || ${#parts[@]} -eq 0 ]] ; then
    if [[ $minutes -eq 1 ]] ; then
      parts+=("1 minute")
    else
      parts+=("$minutes minutes")
    fi
  fi

  local result="${parts[0]}"
  for ((i=1; i<${#parts[@]}; i++)) ; do
    result="$result ${parts[$i]}"
  done

  echo "$result"
}

# Function to convert timing to seconds
function timing_to_seconds() {
  local timing="$1"
  local number="${timing%?}"
  local unit="${timing: -1}"

  case "$unit" in
    h) echo $((number * 3600)) ;;
    m) echo $((number * 60)) ;;
    s) echo "$number" ;;
    *) echo "0" ;;
  esac
}

# Date format functions (shared with notify-at)
# Format detection function
function detect_time_format() {
  local time_input="$1"

  if [[ $time_input =~ ^[0-9]{4}-[0-9]{2}-[0-9]{2}[[:space:]][0-9]{2}:[0-9]{2}$ ]] ; then
    echo "YYYY-MM-DD HH:MM"
  elif [[ $time_input =~ ^[0-9]{2}-[0-9]{2}[[:space:]][0-9]{2}:[0-9]{2}$ ]] ; then
    echo "MM-DD HH:MM"
  elif [[ $time_input =~ ^[0-9]{2}:[0-9]{2}$ ]] ; then
    echo "HH:MM"
  else
    echo "INVALID"
  fi
}

# Date normalization function
function normalize_datetime() {
  local time_input="$1"
  local format="$2"
  local current_year
  current_year=$(date +%Y)

  case "$format" in
    "HH:MM")
      echo "$(date +%Y-%m-%d) $time_input"
      ;;
    "MM-DD HH:MM")
      echo "$current_year-$time_input"
      ;;
    "YYYY-MM-DD HH:MM")
      echo "$time_input"
      ;;
  esac
}

# Past date validation function
function validate_future_datetime() {
  local normalized_datetime="$1"
  local original_format="$2"
  local current_timestamp
  current_timestamp=$(date +%s)
  local target_timestamp

  # Only validate future dates for new formats
  if [[ "$original_format" != "HH:MM" ]] ; then
    if date --version &> /dev/null ; then
      target_timestamp=$(date -d "$normalized_datetime" +%s 2>/dev/null || return 1)
    else
      target_timestamp=$(date -j -f "%Y-%m-%d %H:%M" "$normalized_datetime" +%s 2>/dev/null || return 1)
    fi

    if [[ $target_timestamp -le $current_timestamp ]] ; then
      echo "Error: Specified date/time is in the past: $normalized_datetime" >&2
      return 1
    fi
  fi

  return 0
}

# Calculate target time using new format support
now=$(date +%s)

format=$(detect_time_format "$time")
if [[ $format == "INVALID" ]] ; then
  echo "Error: Invalid time format. Use HH:MM, MM-DD HH:MM, or YYYY-MM-DD HH:MM"
  exit 1
fi

normalized_datetime=$(normalize_datetime "$time" "$format")
if ! validate_future_datetime "$normalized_datetime" "$format" ; then
  exit 1
fi

# Unified date parsing for both GNU and BSD
if date --version >/dev/null 2>&1 ; then
  if ! target=$(date -d "$normalized_datetime" +%s 2>/dev/null) ; then
    echo "Error: Invalid date/time format"
    exit 1
  fi
else
  if ! target=$(date -j -f "%Y-%m-%d %H:%M" "$normalized_datetime" +%s 2>/dev/null) ; then
    echo "Error: Invalid date/time format"
    exit 1
  fi
fi

# Only add 24 hours for HH:MM format when time is in the past
if [[ $format == "HH:MM" && $target -le $now ]] ; then
  target=$((target + 86400))
fi

echo "Cascade notifications scheduled for: $time"
echo "Title: $title"
echo "Message: $message"
echo ""

# Get script directory for notify commands
script_dir="$(cd -- "$(dirname -- "${BASH_SOURCE:-$0}")" && pwd)"

# Send immediate notification if 'now' was specified
if [[ "$send_now" == true ]] ; then
  echo "Sending immediate notification..."
  now_message="$message (now)"

  if [[ "$local_mode" == true || ( "$local_mode" == false && "$mobile_mode" == false ) ]] ; then
    "$script_dir/notify" "$title" "$now_message" "$sound" &
  fi

  if [[ "$mobile_mode" == true ]] ; then
    "$script_dir/notify-ntfy" "$title" "$now_message" &
  fi
fi

# If no timings specified, show single notification at target time
if [[ ${#timings[@]} -eq 0 ]] ; then
  seconds=$((target - now))
  duration=$(format_duration "$seconds")
  echo "Single notification: $duration later"

  notify-at "$time" "$title" "$message" "$sound" "${notify_at_options[@]}" &

  echo "Process ID: $!"
  exit 0
fi

# Schedule notifications for each timing
pids=()
for timing in "${timings[@]}" ; do
  offset_seconds=$(timing_to_seconds "$timing")
  notification_time=$((target - offset_seconds))

  # Skip if notification time is in the past
  if [[ $notification_time -le $now ]] ; then
    echo "Skipping $timing notification (time already passed)"
    continue
  fi

  sleep_seconds=$((notification_time - now))
  duration=$(format_duration "$sleep_seconds")

  # Create timing-specific message
  timing_message="$message ($timing before)"

  echo "$timing notification: in $duration"

  # Calculate the absolute time for this notification
  notification_datetime=$(date -d "@$notification_time" +"%Y-%m-%d %H:%M" 2>/dev/null || date -r "$notification_time" +"%Y-%m-%d %H:%M")

  (
    notify-at "$notification_datetime" "$title" "$timing_message" "$sound" "${notify_at_options[@]}"
  ) &

  pids+=($!)
done

echo ""
echo "Process IDs: ${pids[*]}"

# https://github.com/aiya000/bash-toys
#
# The MIT License (MIT)
#
# Copyright (c) 2025- aiya000
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
