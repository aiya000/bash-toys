#!/bin/bash

# See ../doc/bin.md for description

function show_help () {
  cat << 'EOF'
rm-dust - Alternative to rm that moves files and directories to dustbox instead of deletion

Usage:
  rm-dust FILE|DIR...
  rm-dust --restore [FILE|DIR...]
  rm-dust --restore --keep [FILE|DIR...]
  rm-dust --help

Arguments:
  FILE|DIR...      Files or directories to move to dustbox or restore

Options:
  -h, --help      Show this help message
  --restore       Restore files or directories from dustbox
  --keep          Used with --restore: copy from dustbox instead of moving
                  (leaves the original in dustbox intact)

Environment Variables:
  BASH_TOYS_DUSTBOX_DIR     Directory to store dustbox files (default: ~/.backup/dustbox)
  BASH_TOYS_RESTORE_KEEP    Set to '1' to make --keep the default for --restore
                            (--keep flag always takes precedence over this variable)

Notes:
  - Files and directories are moved to $BASH_TOYS_DUSTBOX_DIR organized by date-hour directories
  - Files are stored in format: YYYY-MM-DD-HH/+full+path+filename.HH:MM[.ext]
  - Directories are stored in format: YYYY-MM-DD-HH/+full+path+dirname.HH:MM/
  - Paths are encoded with / replaced by +
  - Use --restore to interactively select and restore files or directories
  - Interactive restore shows: YYYY-MM-DD-HH HH:MM: /original/path
EOF
}

restore_mode=false
keep_flag=false  # whether --keep was explicitly passed
args=()
for arg in "$@"; do
  if [[ $arg == '--restore' ]] ; then
    restore_mode=true
  elif [[ $arg == '--keep' ]] ; then
    keep_flag=true
  else
    args+=("$arg")
  fi
done
set -- "${args[@]}"

[[ $1 == '--help' || $1 == '-h' ]] && show_help && exit 0

if [[ $keep_flag == 'true' && $restore_mode == 'false' ]] ; then
  echo "Error: --keep requires --restore" >&2
  exit 1
fi

dir=$(dirname "$0")

# shellcheck disable=SC1091
source "$dir/../define-options.sh"

# Determine keep_mode:
# Priority: --keep flag > BASH_TOYS_RESTORE_KEEP env var
# Warn if --keep is explicitly passed while BASH_TOYS_RESTORE_KEEP=0
keep_mode=false
if [[ ${BASH_TOYS_RESTORE_KEEP:-} == '1' ]] ; then
  keep_mode=true
fi
if [[ $keep_flag == 'true' ]] ; then
  if [[ ${BASH_TOYS_RESTORE_KEEP:-} == '0' ]] ; then
    echo "Warning: --keep specified but BASH_TOYS_RESTORE_KEEP=0; --keep takes precedence" >&2
  fi
  keep_mode=true
fi

if [[ ! -d $BASH_TOYS_DUSTBOX_DIR ]] ; then
  mkdir -p "$BASH_TOYS_DUSTBOX_DIR"
fi

if [[ $restore_mode == 'true' ]] ; then
  # Restore mode
  if [[ $# -eq 0 ]] ; then
    # Interactive mode - stream entries to filter progressively (most recent first)
    if [[ ! -d $BASH_TOYS_DUSTBOX_DIR ]] || [[ -z "$(ls -A "$BASH_TOYS_DUSTBOX_DIR" 2>/dev/null)" ]] ; then
      echo "Dustbox is empty"
      exit 0
    fi

    # Temp file for display_line -> dustbox relative path mapping
    # (Avoids declare -A which requires bash 4+)
    map_file=$(mktemp)

    # Stream entries directly to filter without pre-building the full list.
    # Date-hour dirs are processed in reverse order (most recent first).
    selected_lines=$(
      {
        while IFS= read -r date_hour ; do
          [[ -z $date_hour ]] && continue
          date_dir="${BASH_TOYS_DUSTBOX_DIR}/${date_hour}"
          [[ -d $date_dir ]] || continue

          while IFS= read -r filename ; do
            [[ -z $filename ]] && continue
            full_path="${date_dir}/${filename}"
            [[ -e $full_path ]] || continue

            is_dir=false
            if [[ -d $full_path ]] ; then
              is_dir=true
              filename="${filename%/}"
            fi

            # Extract time and original path from filename
            # Format: +full+path+name.HH:MM[.ext] (files) or +full+path+dirname.HH:MM (dirs)
            if [[ $filename =~ \.([0-9]{2}:[0-9]{2})(\.(.+))?$ ]] ; then
              time_part="${BASH_REMATCH[1]}"
              ext_part="${BASH_REMATCH[2]}"
              rest="${filename%.$time_part*}"
            else
              continue
            fi

            # Decode path: replace ++ with placeholder, + with /, then placeholder with +
            original_path=$(echo "$rest" | sed 's/++/%PLUS%/g;s/+/\//g;s/%PLUS%/+/g')
            if [[ $is_dir == false ]] ; then
              original_path="${original_path}${ext_part}"
            else
              original_path="${original_path}/"
            fi

            display_line="$date_hour $time_part: $original_path"
            # Write mapping before echoing to filter (ensures entry is recorded
            # before the user can possibly select it)
            printf '%s|||%s\n' "$display_line" "${date_hour}/${filename}" >> "$map_file"
            echo "$display_line"
          done < <(ls -1 "$date_dir" 2>/dev/null | sort -r)
        done < <(ls -1 "$BASH_TOYS_DUSTBOX_DIR" 2>/dev/null | sort -r)
      } | eval "$BASH_TOYS_INTERACTIVE_FILTER"
    )

    if [[ -z $selected_lines ]] ; then
      echo "No files or directories selected"
      rm -f "$map_file"
      exit 0
    fi

    # Process each selected file
    while IFS= read -r selected_line ; do
      [[ -z $selected_line ]] && continue

      # Look up dustbox path from mapping file
      relative_path=$(grep -F "${selected_line}|||" "$map_file" | head -1 | sed 's/^.*|||//')
      if [[ -z $relative_path ]] ; then
        echo "Warning: Could not find file for selection: $selected_line" >&2
        continue
      fi

      # Extract original path from the selected line
      original_path=$(echo "$selected_line" | sed -E 's/^[0-9]{4}-[0-9]{2}-[0-9]{2}-[0-9]{2} [0-9]{2}:[0-9]{2}: //')

      # Remove trailing slash if present (for directories)
      original_path="${original_path%/}"

      # Create parent directory if needed
      parent_dir=$(dirname "$original_path")
      if [[ $parent_dir != '.' ]] && [[ ! -d $parent_dir ]] ; then
        mkdir -p "$parent_dir"
      fi

      if [[ $keep_mode == 'true' ]] ; then
        echo cp -ir "$BASH_TOYS_DUSTBOX_DIR/$relative_path" "$original_path"
        cp -ir "$BASH_TOYS_DUSTBOX_DIR/$relative_path" "$original_path"
      else
        echo mv -i "$BASH_TOYS_DUSTBOX_DIR/$relative_path" "$original_path"
        mv -i "$BASH_TOYS_DUSTBOX_DIR/$relative_path" "$original_path"
      fi
    done <<< "$selected_lines"

    rm -f "$map_file"
  else
    # Direct file/directory restoration with path pattern: date-hour/name
    for arg in "$@" ; do
      # Check if arg contains a /
      if [[ $arg == */* ]] ; then
        # Full path in dustbox (date-hour/name)
        dustbox_path="$arg"
      else
        # Just name, need to search for it
        found=false
        for date_dir in "$BASH_TOYS_DUSTBOX_DIR"/*/ ; do
          if [[ -e "$date_dir/$arg" ]] ; then
            dustbox_path="$(basename "$date_dir")/$arg"
            found=true
            break
          fi
        done

        if [[ $found == 'false' ]] ; then
          echo "File or directory not found in dustbox: $arg"
          continue
        fi
      fi

      full_dustbox_path="$BASH_TOYS_DUSTBOX_DIR/$dustbox_path"

      if [[ ! -e $full_dustbox_path ]] ; then
        echo "File or directory not found in dustbox: $dustbox_path"
        continue
      fi

      filename=$(basename "$dustbox_path")

      # Check if it's a directory
      is_dir=false
      if [[ -d $full_dustbox_path ]] ; then
        is_dir=true
        # Remove trailing slash if present
        filename="${filename%/}"
      fi

      # Extract original path from filename
      # Format: +full+path+name.HH:MM[.ext] (for files) or +full+path+dirname.HH:MM (for directories)
      if [[ $filename =~ \.([0-9]{2}:[0-9]{2})(\.(.+))?$ ]] ; then
        time_part="${BASH_REMATCH[1]}"
        ext_part="${BASH_REMATCH[2]}"
        # Remove .HH:MM[.ext] from the end
        rest="${filename%.$time_part*}"
      else
        echo "Invalid filename format: $filename"
        continue
      fi

      # Decode path: replace ++ with placeholder, + with /, then placeholder with +
      original_path=$(echo "$rest" | sed 's/++/%PLUS%/g;s/+/\//g;s/%PLUS%/+/g')
      # Add extension back if present (files only)
      if [[ $is_dir == false ]] ; then
        original_path="${original_path}${ext_part}"
      fi

      # Create parent directory if needed
      parent_dir=$(dirname "$original_path")
      if [[ $parent_dir != '.' ]] && [[ ! -d $parent_dir ]] ; then
        mkdir -p "$parent_dir"
      fi

      if [[ $keep_mode == 'true' ]] ; then
        echo cp -ir "$full_dustbox_path" "$original_path"
        cp -ir "$full_dustbox_path" "$original_path"
      else
        echo mv -i "$full_dustbox_path" "$original_path"
        mv -i "$full_dustbox_path" "$original_path"
      fi
    done
  fi
else
  # Normal mode - move files and directories to dustbox
  for file in "$@" ; do
    # Check if file or directory exists
    if [[ ! -e $file ]] ; then
      echo "Error: File or directory not found: $file" >&2
      continue
    fi

    # Convert to absolute path and resolve symlinks/..
    if command -v realpath >/dev/null 2>&1 ; then
      abs_path=$(realpath "$file")
    else
      # Fallback if realpath is not available
      if [[ $file != /* ]] ; then
        abs_path="$(cd "$(dirname "$file")" && pwd)/$(basename "$file")"
      else
        abs_path="$file"
      fi
    fi

    # Extract extension (only for files, not directories)
    ext=''
    if [[ -f $file ]] ; then
      maybe_ext=${abs_path##*.}
      if [[ $abs_path != "$maybe_ext" ]] && [[ $maybe_ext != '' ]] ; then
        ext=".$maybe_ext"
        base_path="${abs_path%.*}"
      else
        base_path="$abs_path"
      fi
    else
      base_path="$abs_path"
    fi

    # Create date-hour directory
    date_hour=$(date +'%Y-%m-%d-%H')
    date_hour_dir="$BASH_TOYS_DUSTBOX_DIR/$date_hour"
    if [[ ! -d $date_hour_dir ]] ; then
      mkdir -p "$date_hour_dir"
    fi

    # Create new filename: +full+path+filename.HH:MM[.ext]
    # Escape + in the path as ++ before encoding / as + to avoid ambiguity
    encoded_path=$(echo "$base_path" | sed 's/+/++/g;s;/;+;g')
    time_suffix=$(date +'%H:%M')
    new_name="${encoded_path}.${time_suffix}${ext}"

    echo mv "$file" "$date_hour_dir/$new_name"
    mv "$file" "$date_hour_dir/$new_name"
  done
fi

# https://github.com/aiya000/bash-toys
#
# The MIT License (MIT)
#
# Copyright (c) 2025- aiya000
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
