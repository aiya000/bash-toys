#!/bin/bash

# Sends notification at specified time via ntfy.sh (mobile notification)
#
# NOTE:
# This script is intended to be called indirectly from `./notify-at`.
# If called directly, discrepancies may occur with the command name in the help output.
# Please consider implementing an alias or similar workaround.
#
# Requirements:
# - curl
# - BASH_TOYS_NTFY_TOPIC environment variable
#
# Supported time formats:
# - HH:MM                - Time today (if past, then tomorrow)
# - MM-DD HH:MM          - Month-day-time (must be future)
# - YYYY-MM-DD HH:MM     - Year-month-day-time (must be future)
#
# ```shell-session
# $ notify-at-ntfy 12:00 "Meeting" "Team meeting"                    # Today at 12:00
# $ notify-at-ntfy "01-15 09:00" "Reminder" "New year meeting"       # January 15 at 09:00
# $ notify-at-ntfy "2027-01-15 09:00" "Reminder" "Future meeting"    # Future date
# ```
#
# See also `$ notify-at-ntfy --help`

set -e

function show_help() {
  cat << 'EOF'
notify-at - Sends notification at specified time via ntfy.sh (mobile version)

Usage:
  notify-at TIME title message
  notify-at -l | --list
  notify-at -c JOB_ID | --cancel JOB_ID
  notify-at --help

Arguments:
  TIME      Time in one of the supported formats
  title     Notification title
  message   Notification message
  JOB_ID    Job ID of scheduled job to cancel (from 'notify-at -l')

Options:
  -l, --list              List all scheduled jobs (not supported for ntfy.sh)
  -c, --cancel JOB_ID     Cancel scheduled job by Job ID (not supported for ntfy.sh)
  --help                  Show this help message

TIME formats:
  HH:MM                - Time today (if past, then tomorrow)
  MM-DD HH:MM          - Month-day-time (must be future)
  YYYY-MM-DD HH:MM     - Year-month-day-time (must be future)

Environment Variables:
  BASH_TOYS_NTFY_TOPIC    Required. Your ntfy.sh topic name.

Examples:
  notify-at 13:30 'Reminder' 'Meeting time'
  notify-at '01-15 09:00' 'Reminder' 'New year meeting'
  notify-at '2027-01-15 09:00' 'Reminder' 'Future meeting'

Note:
  This tool uses ntfy.sh's scheduled delivery feature.
  Maximum delay is 3 days. For longer delays, the notification
  will be scheduled using the local scheduler (at/launchd).
EOF
}

# Check for ntfy topic
function check_ntfy_topic() {
  if [[ -z "${BASH_TOYS_NTFY_TOPIC:-}" ]] ; then
    echo "Error: BASH_TOYS_NTFY_TOPIC environment variable is required" >&2
    exit 1
  fi
}

# Option parsing
[[ $1 == --help ]] && show_help && exit 0

check_ntfy_topic

if [[ $1 == "-l" || $1 == "--list" ]] ; then
  echo "Note: Listing scheduled jobs is not supported for ntfy.sh notifications."
  echo "Once a notification is scheduled with ntfy.sh, it cannot be listed or cancelled."
  exit 0
fi

if [[ $1 == "-c" || $1 == "--cancel" ]] ; then
  echo "Note: Cancelling scheduled jobs is not supported for ntfy.sh notifications."
  echo "Once a notification is scheduled with ntfy.sh, it cannot be cancelled."
  exit 1
fi

if [[ $# -lt 3 ]] ; then
  show_help
  exit 1
fi

time="$1"
title="$2"
message="$3"
now=$(date +%s)

# Format seconds to human-readable duration
# e.g., "1 day 2 hours 30 minutes later"
function format_duration() {
  local total_seconds="$1"
  local parts=()

  local days=$((total_seconds / 86400))
  local remaining=$((total_seconds % 86400))
  local hours=$((remaining / 3600))
  remaining=$((remaining % 3600))
  local minutes=$((remaining / 60))

  if [[ $days -gt 0 ]] ; then
    if [[ $days -eq 1 ]] ; then
      parts+=("1 day")
    else
      parts+=("$days days")
    fi
  fi

  if [[ $hours -gt 0 ]] ; then
    if [[ $hours -eq 1 ]] ; then
      parts+=("1 hour")
    else
      parts+=("$hours hours")
    fi
  fi

  if [[ $minutes -gt 0 || ${#parts[@]} -eq 0 ]] ; then
    if [[ $minutes -eq 1 ]] ; then
      parts+=("1 minute")
    else
      parts+=("$minutes minutes")
    fi
  fi

  local result="${parts[0]}"
  for ((i=1; i<${#parts[@]}; i++)) ; do
    result="$result ${parts[$i]}"
  done

  echo "$result later"
}

# Format detection function
function detect_time_format() {
  local time_input="$1"

  if [[ $time_input =~ ^[0-9]{4}-[0-9]{2}-[0-9]{2}[[:space:]][0-9]{2}:[0-9]{2}$ ]] ; then
    echo "YYYY-MM-DD HH:MM"
  elif [[ $time_input =~ ^[0-9]{2}-[0-9]{2}[[:space:]][0-9]{2}:[0-9]{2}$ ]] ; then
    echo "MM-DD HH:MM"
  elif [[ $time_input =~ ^[0-9]{2}:[0-9]{2}$ ]] ; then
    echo "HH:MM"
  else
    echo "INVALID"
  fi
}

# Date normalization function
function normalize_datetime() {
  local time_input="$1"
  local format="$2"

  local current_year
  current_year=$(date +%Y)

  case "$format" in
    "HH:MM")
      echo "$(date +%Y-%m-%d) $time_input"
      ;;
    "MM-DD HH:MM")
      echo "$current_year-$time_input"
      ;;
    "YYYY-MM-DD HH:MM")
      echo "$time_input"
      ;;
  esac
}

# Past date validation function
function validate_future_datetime() {
  local normalized_datetime="$1"
  local original_format="$2"
  local target_timestamp
  local current_timestamp
  current_timestamp=$(date +%s)

  # Only validate future dates for new formats
  if [[ "$original_format" != "HH:MM" ]] ; then
    if date --version &> /dev/null ; then
      target_timestamp=$(date -d "$normalized_datetime" +%s 2>/dev/null || return 1)
    else
      target_timestamp=$(date -j -f "%Y-%m-%d %H:%M" "$normalized_datetime" +%s 2>/dev/null || return 1)
    fi

    if [[ $target_timestamp -le $current_timestamp ]] ; then
      echo "Error: Specified date/time is in the past: $normalized_datetime" >&2
      return 1
    fi
  fi

  return 0
}

# Unified date parsing with new format support
format=$(detect_time_format "$time")
if [[ $format == "INVALID" ]] ; then
  echo "Error: Invalid time format. Use HH:MM, MM-DD HH:MM, or YYYY-MM-DD HH:MM"
  exit 1
fi

normalized_datetime=$(normalize_datetime "$time" "$format")
if ! validate_future_datetime "$normalized_datetime" "$format" ; then
  exit 1
fi

# Unified date parsing for both GNU and BSD
if date --version >/dev/null 2>&1 ; then
  if ! target=$(date -d "$normalized_datetime" +%s 2>/dev/null) ; then
    echo "Error: Invalid date/time format"
    exit 1
  fi
else
  if ! target=$(date -j -f "%Y-%m-%d %H:%M" "$normalized_datetime" +%s 2>/dev/null) ; then
    echo "Error: Invalid date/time format"
    exit 1
  fi
fi

# Only add 24 hours for HH:MM format when time is in the past
# Use -lt (not -le) because target has seconds=00, so target==now means "this minute"
if [[ $format == "HH:MM" && $target -lt $now ]] ; then
  target=$((target + 86400))
fi

seconds=$((target - now))
duration=$(format_duration "$seconds")

echo "Mobile notification scheduled: $time ($duration)"
echo "Title: $title"
echo "Message: $message"

# ntfy.sh has a maximum delay of 3 days (259200 seconds)
max_ntfy_delay=259200

if [[ $seconds -gt $max_ntfy_delay ]] ; then
  echo ""
  echo "Note: Delay exceeds ntfy.sh's 3-day limit. Using local scheduler as fallback."

  # Get the full path to notify command
  script_dir="$(cd -- "$(dirname -- "${BASH_SOURCE:-$0}")" && pwd)"

  # Use at command or launchd to schedule notify --mobile
  case "$(uname -s)" in
    Darwin)
      # macOS: use launchd-style scheduling via at
      # Schedule notify --mobile at the target time
      at_time=$(date -r "$target" +"%Y%m%d%H%M")
      job_output=$(echo "\"$script_dir/notify\" --mobile '$title' '$message'" | at -t "$at_time" 2>&1)
      job_id=$(echo "$job_output" | grep -o 'job [0-9]*' | awk '{print $2}')
      if [[ -n "$job_id" ]] ; then
        echo "Job ID: $job_id (scheduled via at command)"
      else
        echo "Error: Failed to schedule notification"
        exit 1
      fi
      ;;
    *)
      # Linux: use at command
      at_time=$(date -d "@$target" +"%Y%m%d%H%M")
      job_output=$(echo "\"$script_dir/notify\" --mobile '$title' '$message'" | at -t "$at_time" 2>&1)
      job_id=$(echo "$job_output" | grep -o 'job [0-9]*' | awk '{print $2}')
      if [[ -n "$job_id" ]] ; then
        echo "Job ID: $job_id (scheduled via at command)"
      else
        echo "Error: Failed to schedule notification"
        exit 1
      fi
      ;;
  esac
else
  # Use ntfy.sh's scheduled delivery
  if curl -s \
    -H "Title: $title" \
    -H "At: $target" \
    -d "$message" \
    "https://ntfy.sh/$BASH_TOYS_NTFY_TOPIC" > /dev/null ; then
    echo "Scheduled via ntfy.sh (no Job ID - cannot be cancelled)"
  else
    echo "Error: Failed to schedule notification via ntfy.sh" >&2
    exit 1
  fi
fi

# https://github.com/aiya000/bash-toys
#
# The MIT License (MIT)
#
# Copyright (c) 2025- aiya000
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
