#!/bin/bash

# See ../doc/bin.md for description

set -e

function show_help() {
  cat << 'EOF'
notify-at - Sends notification at specified time with flexible date formats

Usage:
  notify-at [options] TIME title message [sound]
  notify-at -l | --list
  notify-at -c JOB_ID [-c JOB_ID ...] | --cancel JOB_ID [--cancel JOB_ID ...]
  notify-at --help

Arguments:
  TIME      Time in one of the supported formats
  title     Notification title
  message   Notification message
  sound     Optional sound file (default: configured sound, only for --local)
  JOB_ID    Job ID of scheduled job to cancel (from 'notify-at -l')

Options:
  --ntfy                Send notification via ntfy.sh
  --local               Send notification to local desktop (default if no options specified)
  -l, --list            List all scheduled jobs
  -c, --cancel JOB_ID   Cancel scheduled job by Job ID
  -h, --help            Show this help message

Note: If --ntfy is specified without --local, only ntfy.sh notification is sent.
      If neither is specified, --local is assumed.

Environment Variables:
  BASH_TOYS_NTFY_TOPIC    Required when using --ntfy. Your ntfy.sh topic name.

TIME formats:
  HH:MM                - Time today (if past, then tomorrow)
  MM-DD HH:MM          - Month-day-time (must be future)
  YYYY-MM-DD HH:MM     - Year-month-day-time (must be future)

Examples:
  notify-at 13:30 'Reminder' 'Meeting time'
  notify-at '01-15 09:00' 'Reminder' 'New year meeting'
  notify-at '2027-01-15 09:00' 'Reminder' 'Future meeting'
  notify-at 13:30 'Reminder' 'Meeting time' --ntfy
  notify-at 13:30 'Reminder' 'Meeting time' --ntfy --local

Job management:
  notify-at -l                    # List scheduled jobs
  notify-at --cancel 5            # Cancel job with Job ID 5

Note:
  This tool uses the 'at' command for reliable scheduling.
  The 'at' daemon must be enabled on your system:
    macOS: sudo launchctl load -w /System/Library/LaunchDaemons/com.apple.atrun.plist
    Linux: sudo systemctl enable --now atd
EOF
}

# Check if 'at' command is available
function check_at_available() {
  if ! command -v at &>/dev/null ; then
    echo "Error: 'at' command not found. Please install it:"
    echo "  macOS: The 'at' command is built-in but the daemon needs to be enabled:"
    echo "         sudo launchctl load -w /System/Library/LaunchDaemons/com.apple.atrun.plist"
    echo "  Linux: sudo apt install at  (Debian/Ubuntu)"
    echo "         sudo yum install at  (RHEL/CentOS)"
    exit 1
  fi
}

# Schedule a job using the 'at' command
# Arguments: $1=target_timestamp $2=title $3=message $4=sound $5=notify_cmd $6=notify_ntfy_cmd $7=local_mode $8=mobile_mode
# Output: job_id on success, empty on failure
function schedule_at_job() {
  local target_timestamp="$1"
  local title="$2"
  local message="$3"
  local sound="$4"
  local notify_cmd="$5"
  local notify_ntfy_cmd="$6"
  local local_mode="$7"
  local mobile_mode="$8"

  # Convert timestamp to at -t format: YYYYMMDDhhmm
  local at_time
  if date --version >/dev/null 2>&1 ; then
    # GNU date
    at_time=$(date -d "@$target_timestamp" +"%Y%m%d%H%M")
  else
    # BSD date
    at_time=$(date -r "$target_timestamp" +"%Y%m%d%H%M")
  fi

  # Escape single quotes in title and message for the tag comment
  local escaped_title="${title//\'/\'\\\'\'}"
  local escaped_message="${message//\'/\'\\\'\'}"

  # Build target mode string
  local target_modes=()
  [[ "$local_mode" == true ]] && target_modes+=("local")
  [[ "$mobile_mode" == true ]] && target_modes+=("mobile")
  local target_mode_str
  IFS=',' ; target_mode_str="${target_modes[*]}" ; IFS=' '

  # Build command list
  # Note: at jobs don't inherit user environment, so we export BASH_TOYS_NTFY_TOPIC explicitly
  local commands=""
  if [[ "$local_mode" == true ]] ; then
    commands="\"$notify_cmd\" '$title' '$message' '$sound'"
  fi
  if [[ "$mobile_mode" == true ]] ; then
    local ntfy_command="export BASH_TOYS_NTFY_TOPIC='$BASH_TOYS_NTFY_TOPIC'; \"$notify_ntfy_cmd\" '$title' '$message'"
    if [[ -n "$commands" ]] ; then
      commands="$commands
$ntfy_command"
    else
      commands="$ntfy_command"
    fi
  fi

  # Create job with identification tag
  # The tag allows us to identify notify-at jobs when listing
  local job_output
  job_output=$(cat << EOF | at -t "$at_time" 2>&1
# NOTIFY_AT_JOB title='${escaped_title}' message='${escaped_message}' mode='${target_mode_str}'
$commands
EOF
  )

  # Extract job ID from output
  # macOS/BSD: "job 5 at Wed Jan 15 12:00:00 2025"
  # Linux: "job 5 at Wed Jan 15 12:00:00 2025"
  local job_id
  job_id=$(echo "$job_output" | grep -o 'job [0-9]*' | awk '{print $2}')

  echo "$job_id"
}

# Job management functions
function list_jobs() {
  # Use atq to list scheduled at jobs
  local at_jobs
  at_jobs=$(atq 2>/dev/null || true)

  if [[ -z "$at_jobs" ]] ; then
    echo "No scheduled jobs found."
    return 0
  fi

  # Array to store "timestamp|job_line" for sorting
  local job_entries=()

  while IFS= read -r line ; do
    # Skip empty lines
    [[ -z "$line" ]] && continue

    # Parse atq output
    # macOS: "5	Wed Jan 15 12:00:00 2025"
    # Linux: "5	Wed Jan 15 12:00:00 2025 a user"
    local job_id
    job_id=$(echo "$line" | awk '{print $1}')

    # Get job content to check if it's a notify-at job
    local job_content
    job_content=$(at -c "$job_id" 2>/dev/null || true)

    # Check for NOTIFY_AT_JOB tag
    if echo "$job_content" | grep -q "NOTIFY_AT_JOB" ; then
      # Extract title, message, and mode from tag
      local tag_line
      tag_line=$(echo "$job_content" | grep "NOTIFY_AT_JOB")

      local title message target_mode
      # Extract title: remove everything before "title='" and after the closing "'"
      title="${tag_line#*title=\'}"
      title="${title%%\'*}"
      # Extract message: remove everything before "message='" and after the closing "'"
      message="${tag_line#*message=\'}"
      message="${message%%\'*}"
      # Extract mode: remove everything before "mode='" and after the closing "'"
      if [[ "$tag_line" == *"mode='"* ]] ; then
        target_mode="${tag_line#*mode=\'}"
        target_mode="${target_mode%%\'*}"
      else
        target_mode="local"
      fi

      # Extract time from atq output (format varies by platform)
      # Try to get HH:MM from the line
      local time_str
      time_str=$(echo "$line" | awk '{print $5}' | cut -d: -f1,2)

      # Convert time to sortable timestamp (using today's date as base)
      local sort_key
      sort_key=$(date -j -f "%H:%M" "$time_str" +%s 2>/dev/null || echo "0")

      local job_line
      job_line=$(printf "%-8s %-8s %-14s %-15s %s" "$job_id" "$time_str" "$target_mode" "${title:0:15}" "${message:0:40}")
      job_entries+=("${sort_key}|${job_line}")
    fi
  done <<< "$at_jobs"

  # Check if any valid jobs were found
  if [[ ${#job_entries[@]} -eq 0 ]] ; then
    echo "No scheduled jobs found."
    return 0
  fi

  # Display header and jobs
  printf "%-8s %-8s %-14s %-15s %s\n" "JOB_ID" "TIME" "TARGET" "TITLE" "MESSAGE"
  printf "%-8s %-8s %-14s %-15s %s\n" "------" "----" "------" "-----" "-------"

  # Sort by timestamp and display (remove timestamp prefix)
  printf '%s\n' "${job_entries[@]}" | sort -t'|' -k1 -n | cut -d'|' -f2-
}

function cancel_job() {
  local target_job_id="$1"

  if [[ -z "$target_job_id" ]] ; then
    echo "Error: Job ID required for cancel operation"
    echo "Usage: $0 -c JOB_ID [-c JOB_ID ...]"
    echo "       $0 --cancel JOB_ID [--cancel JOB_ID ...]"
    return 1
  fi

  # Verify it's an existing at job
  local job_content
  job_content=$(at -c "$target_job_id" 2>/dev/null || true)

  if [[ -z "$job_content" ]] ; then
    echo "Error: Job with ID $target_job_id not found"
    return 1
  fi

  # Verify it's a notify-at job
  if ! echo "$job_content" | grep -q "NOTIFY_AT_JOB" ; then
    echo "Error: Job $target_job_id is not a notify-at job"
    return 1
  fi

  # Remove the job using atrm
  if atrm "$target_job_id" 2>/dev/null ; then
    echo "Job $target_job_id cancelled successfully"
  else
    echo "Error: Failed to cancel job $target_job_id"
    return 1
  fi
}

# Option parsing
[[ $1 == --help || $1 == -h ]] && show_help && exit 0

# Check if 'at' command is available (required for all operations except --help)
check_at_available

if [[ $1 == "-l" || $1 == "--list" ]] ; then
  list_jobs
  exit 0
fi

# Handle multiple -c/--cancel options
if [[ $1 == "-c" || $1 == "--cancel" ]] ; then
  job_ids=()
  exit_code=0

  # Collect all job IDs from -c/--cancel options
  while [[ $# -gt 0 ]] ; do
    case "$1" in
      -c|--cancel)
        if [[ -n "$2" && ! "$2" =~ ^- ]] ; then
          job_ids+=("$2")
          shift 2
        else
          echo "Error: -c/--cancel requires a job ID argument"
          exit 1
        fi
        ;;
      *)
        echo "Error: Unexpected argument: $1"
        exit 1
        ;;
    esac
  done

  # Cancel all collected jobs
  for job_id in "${job_ids[@]}" ; do
    if ! cancel_job "$job_id" ; then
      exit_code=1
    fi
  done

  exit $exit_code
fi

# Parse arguments - extract --ntfy and --local options
mobile_mode=false
local_mode=false
positional_args=()

for arg in "$@" ; do
  case "$arg" in
    --ntfy)
      mobile_mode=true
      ;;
    --mobile)  # For backward compatibility
      mobile_mode=true
      ;;
    --local)
      local_mode=true
      ;;
    *)
      positional_args+=("$arg")
      ;;
  esac
done

# Default to local mode if neither is specified
if [[ "$mobile_mode" == false && "$local_mode" == false ]] ; then
  local_mode=true
fi

# Validate ntfy topic when mobile mode is requested
if [[ "$mobile_mode" == true && -z "${BASH_TOYS_NTFY_TOPIC:-}" ]] ; then
  echo "Error: BASH_TOYS_NTFY_TOPIC environment variable is required for --ntfy option" >&2
  exit 1
fi

if [[ ${#positional_args[@]} -lt 3 ]] ; then
  show_help
  exit 1
fi

time="${positional_args[0]}"
title="${positional_args[1]}"
message="${positional_args[2]}"
sound="${positional_args[3]:-${BASH_TOYS_NOTIFY_AT_DEFAULT_SOUND:-default}}"
now=$(date +%s)

# Format seconds to human-readable duration
# e.g., "1 day 2 hours 30 minutes later"
function format_duration() {
  local total_seconds="$1"
  local parts=()

  local days=$((total_seconds / 86400))
  local remaining=$((total_seconds % 86400))
  local hours=$((remaining / 3600))
  remaining=$((remaining % 3600))
  local minutes=$((remaining / 60))

  if [[ $days -gt 0 ]] ; then
    if [[ $days -eq 1 ]] ; then
      parts+=("1 day")
    else
      parts+=("$days days")
    fi
  fi

  if [[ $hours -gt 0 ]] ; then
    if [[ $hours -eq 1 ]] ; then
      parts+=("1 hour")
    else
      parts+=("$hours hours")
    fi
  fi

  if [[ $minutes -gt 0 || ${#parts[@]} -eq 0 ]] ; then
    if [[ $minutes -eq 1 ]] ; then
      parts+=("1 minute")
    else
      parts+=("$minutes minutes")
    fi
  fi

  local result="${parts[0]}"
  for ((i=1; i<${#parts[@]}; i++)) ; do
    result="$result ${parts[$i]}"
  done

  echo "$result later"
}

# Format detection function
function detect_time_format() {
  local time_input="$1"

  if [[ $time_input =~ ^[0-9]{4}-[0-9]{2}-[0-9]{2}[[:space:]][0-9]{2}:[0-9]{2}$ ]] ; then
    echo "YYYY-MM-DD HH:MM"
  elif [[ $time_input =~ ^[0-9]{2}-[0-9]{2}[[:space:]][0-9]{2}:[0-9]{2}$ ]] ; then
    echo "MM-DD HH:MM"
  elif [[ $time_input =~ ^[0-9]{2}:[0-9]{2}$ ]] ; then
    echo "HH:MM"
  else
    echo "INVALID"
  fi
}

# Date normalization function
function normalize_datetime() {
  local time_input="$1"
  local format="$2"

  local current_year
  current_year=$(date +%Y)

  case "$format" in
    "HH:MM")
      echo "$(date +%Y-%m-%d) $time_input"
      ;;
    "MM-DD HH:MM")
      echo "$current_year-$time_input"
      ;;
    "YYYY-MM-DD HH:MM")
      echo "$time_input"
      ;;
  esac
}

# Past date validation function
function validate_future_datetime() {
  local normalized_datetime="$1"
  local original_format="$2"
  local target_timestamp
  local current_timestamp
  current_timestamp=$(date +%s)

  # Only validate future dates for new formats
  if [[ "$original_format" != "HH:MM" ]] ; then
    if date --version &> /dev/null ; then
      target_timestamp=$(date -d "$normalized_datetime" +%s 2>/dev/null || return 1)
    else
      target_timestamp=$(date -j -f "%Y-%m-%d %H:%M" "$normalized_datetime" +%s 2>/dev/null || return 1)
    fi

    if [[ $target_timestamp -le $current_timestamp ]] ; then
      echo "Error: Specified date/time is in the past: $normalized_datetime" >&2
      return 1
    fi
  fi

  return 0
}

# Unified date parsing with new format support
format=$(detect_time_format "$time")
if [[ $format == "INVALID" ]] ; then
  echo "Error: Invalid time format. Use HH:MM, MM-DD HH:MM, or YYYY-MM-DD HH:MM"
  exit 1
fi

normalized_datetime=$(normalize_datetime "$time" "$format")
if ! validate_future_datetime "$normalized_datetime" "$format" ; then
  exit 1
fi

# Unified date parsing for both GNU and BSD
if date --version >/dev/null 2>&1 ; then
  if ! target=$(date -d "$normalized_datetime" +%s 2>/dev/null) ; then
    echo "Error: Invalid date/time format"
    exit 1
  fi
else
  if ! target=$(date -j -f "%Y-%m-%d %H:%M" "$normalized_datetime" +%s 2>/dev/null) ; then
    echo "Error: Invalid date/time format"
    exit 1
  fi
fi

# Only add 24 hours for HH:MM format when time is in the past
# Use -lt (not -le) because target has seconds=00, so target==now means "this minute"
if [[ $format == "HH:MM" && $target -lt $now ]] ; then
  target=$((target + 86400))
fi

seconds=$((target - now))
duration=$(format_duration "$seconds")

echo "Notification scheduled: $time ($duration)"
echo "Title: $title"
echo "Message: $message"
if [[ "$local_mode" == true ]] ; then
  echo "Target: local"
fi
if [[ "$mobile_mode" == true ]] ; then
  echo "Target: mobile (ntfy.sh)"
fi

# Get the full path to notify commands
script_dir="$(cd -- "$(dirname -- "${BASH_SOURCE:-$0}")" && pwd)"
notify_cmd="$script_dir/notify"
notify_ntfy_cmd="$script_dir/notify-ntfy"

# Schedule using at command
job_id=$(schedule_at_job "$target" "$title" "$message" "$sound" "$notify_cmd" "$notify_ntfy_cmd" "$local_mode" "$mobile_mode")

if [[ -n "$job_id" ]] ; then
  echo "Job ID: $job_id"
else
  echo "Error: Failed to schedule notification"
  exit 1
fi

# https://github.com/aiya000/bash-toys
#
# The MIT License (MIT)
#
# Copyright (c) 2025- aiya000
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
