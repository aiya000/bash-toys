#!/bin/bash

# Sends notification at specified time with flexible date formats
#
# Requirements:
# - ./notify
#
# Supported time formats:
# - HH:MM                - Time today (if past, then tomorrow)
# - MM-DD HH:MM          - Month-day-time (must be future)
# - YYYY-MM-DD HH:MM     - Year-month-day-time (must be future)
#
# ```shell-session
# $ notify-at 12:00 "Meeting" "Team meeting"                    # Today at 12:00
# $ notify-at "01-15 09:00" "Reminder" "New year meeting"       # January 15 at 09:00
# $ notify-at "2027-01-15 09:00" "Reminder" "Future meeting"    # Future date
# ```
#
# See also `$ notify-at --help`

set -e

function show_help() {
  cat << 'EOF'
notify-at - Sends notification at specified time with flexible date formats

Usage:
  notify-at TIME title message [sound]
  notify-at -l | --list
  notify-at -c PID | --cancel PID
  notify-at --help

Arguments:
  TIME      Time in one of the supported formats
  title     Notification title
  message   Notification message
  sound     Optional sound file (default: configured sound)
  PID       Process ID of scheduled job to cancel

Options:
  -l, --list           List all scheduled jobs
  -c, --cancel PID     Cancel scheduled job by PID
  --help               Show this help message

TIME formats:
  HH:MM                - Time today (if past, then tomorrow)
  MM-DD HH:MM          - Month-day-time (must be future)
  YYYY-MM-DD HH:MM     - Year-month-day-time (must be future)

Examples:
  notify-at 13:30 'Reminder' 'Meeting time'
  notify-at '01-15 09:00' 'Reminder' 'New year meeting'
  notify-at '2027-01-15 09:00' 'Reminder' 'Future meeting'

Job management:
  notify-at -l                    # List scheduled jobs
  notify-at --cancel 12345        # Cancel job with PID 12345
EOF
}

# Job management functions
function list_jobs() {
  # Use ps to find notify-at processes
  local notify_processes
  notify_processes=$(ps aux | grep "bin/notify-at" | grep -v grep | grep -v "\-l\|\-\-list\|\-c\|\-\-cancel" || true)

  # Check if there are any valid notify-at processes and collect job info
  local job_lines=()

  while IFS= read -r line ; do
    # Skip empty lines
    if [[ -z "$line" ]] ; then
      continue
    fi

    # Extract command line arguments starting from notify-at
    local cmd_part
    cmd_part=$(echo "$line" | grep -o "bin/notify-at.*" || true)

    if [[ -n "$cmd_part" ]] ; then
      # Extract PID (second column)
      local pid
      pid=$(echo "$line" | awk '{print $2}')

      # Parse arguments: notify-at TIME TITLE MESSAGE [SOUND]
      local args_array
      read -ra args_array <<< "$cmd_part"

      if [[ ${#args_array[@]} -ge 4 ]] ; then
        local time="${args_array[1]}"

        # For args with spaces, we need to reconstruct TITLE and MESSAGE
        # Method: everything after TIME and before the last arg (or last 2 if sound file path) is TITLE+MESSAGE
        local all_after_time="${args_array[@]:2}"  # All args after TIME
        local args_count=${#args_array[@]}

        if [[ $args_count -eq 4 ]] ; then
          # notify-at TIME TITLE MESSAGE (no sound)
          local title="${args_array[2]}"
          local message="${args_array[3]}"
        else
          # More than 4 args - check if last arg is a sound file
          local last_arg_idx=$((args_count - 1))
          local last_arg="${args_array[$last_arg_idx]}"

          if [[ $last_arg =~ \.(mp3|wav|m4a|aiff)$ ]] ; then
            # Last arg looks like a sound file
            local remaining_count=$((args_count - 3))  # Exclude notify-at, TIME, and SOUND

            if [[ $remaining_count -eq 1 ]] ; then
              local title="${args_array[2]}"
              local message="(no message)"
            elif [[ $remaining_count -eq 2 ]] ; then
              local title="${args_array[2]}"
              local message="${args_array[3]}"
            else
              # Multiple words - split roughly in half
              local mid=$(( remaining_count / 2 + 2 ))  # +2 to account for notify-at and TIME
              local title_parts=("${args_array[@]:2:$((mid-2))}")
              local message_parts=("${args_array[@]:$mid:$((remaining_count-(mid-2)))}")
              local title="${title_parts[*]}"
              local message="${message_parts[*]}"
            fi
          else
            # No sound file - split remaining args between TITLE and MESSAGE
            local remaining_count=$((args_count - 2))  # Exclude notify-at and TIME
            local mid=$(( remaining_count / 2 + 2 ))  # +2 to account for notify-at and TIME

            local title_parts=("${args_array[@]:2:$((mid-2))}")
            local message_parts=("${args_array[@]:$mid}")
            local title="${title_parts[*]}"
            local message="${message_parts[*]}"
          fi
        fi

        # Store job info in array
        local job_line
        job_line=$(printf "%-8s %-8s %-15s %s" "$pid" "$time" "${title:0:15}" "${message:0:40}")
        job_lines+=("$job_line")
      fi
    fi
  done <<< "$notify_processes"

  # Check if any valid jobs were found
  if [[ ${#job_lines[@]} -eq 0 ]] ; then
    echo "No scheduled jobs found."
    return 0
  fi

  # Display header and jobs
  printf "%-8s %-8s %-15s %s\n" "PID" "TIME" "TITLE" "MESSAGE"
  printf "%-8s %-8s %-15s %s\n" "---" "----" "-----" "-------"

  for job_line in "${job_lines[@]}" ; do
    echo "$job_line"
  done
}

function cancel_job() {
  local target_pid="$1"

  if [[ -z "$target_pid" ]] ; then
    echo "Error: PID required for cancel operation"
    echo "Usage: $0 -c PID"
    echo "       $0 --cancel PID"
    exit 1
  fi

  # Check if PID is actually a notify-at process
  if ! ps aux | grep -q "^ *[^ ]* *$target_pid .* bin/notify-at" 2>/dev/null ; then
    echo "Error: Job with PID $target_pid not found"
    exit 1
  fi

  # Kill the process
  if kill "$target_pid" 2>/dev/null ; then
    echo "Job $target_pid cancelled successfully"
  else
    echo "Error: Failed to cancel job $target_pid (process may have already finished)"
    exit 1
  fi
}

# Option parsing
[[ $1 == --help ]] && show_help && exit 0

if [[ $1 == "-l" || $1 == "--list" ]] ; then
  list_jobs
  exit 0
fi

if [[ $1 == "-c" || $1 == "--cancel" ]] ; then
  cancel_job "$2"
  exit 0
fi


if [[ $# -lt 3 ]] ; then
  show_help
  exit 1
fi

time="$1"
title="$2"
message="$3"
sound="${4:-${BASH_TOYS_NOTIFY_AT_DEFAULT_SOUND:-default}}"
now=$(date +%s)

# Format seconds to human-readable duration
# e.g., "1 day 2 hours 30 minutes later"
function format_duration() {
  local total_seconds="$1"
  local parts=()

  local days=$((total_seconds / 86400))
  local remaining=$((total_seconds % 86400))
  local hours=$((remaining / 3600))
  remaining=$((remaining % 3600))
  local minutes=$((remaining / 60))

  if [[ $days -gt 0 ]] ; then
    if [[ $days -eq 1 ]] ; then
      parts+=("1 day")
    else
      parts+=("$days days")
    fi
  fi

  if [[ $hours -gt 0 ]] ; then
    if [[ $hours -eq 1 ]] ; then
      parts+=("1 hour")
    else
      parts+=("$hours hours")
    fi
  fi

  if [[ $minutes -gt 0 || ${#parts[@]} -eq 0 ]] ; then
    if [[ $minutes -eq 1 ]] ; then
      parts+=("1 minute")
    else
      parts+=("$minutes minutes")
    fi
  fi

  local result="${parts[0]}"
  for ((i=1; i<${#parts[@]}; i++)) ; do
    result="$result ${parts[$i]}"
  done

  echo "$result later"
}

# Format detection function
function detect_time_format() {
  local time_input="$1"

  if [[ $time_input =~ ^[0-9]{4}-[0-9]{2}-[0-9]{2}[[:space:]][0-9]{2}:[0-9]{2}$ ]] ; then
    echo "YYYY-MM-DD HH:MM"
  elif [[ $time_input =~ ^[0-9]{2}-[0-9]{2}[[:space:]][0-9]{2}:[0-9]{2}$ ]] ; then
    echo "MM-DD HH:MM"
  elif [[ $time_input =~ ^[0-9]{2}:[0-9]{2}$ ]] ; then
    echo "HH:MM"
  else
    echo "INVALID"
  fi
}

# Date normalization function
function normalize_datetime() {
  local time_input="$1"
  local format="$2"

  local current_year
  current_year=$(date +%Y)

  case "$format" in
    "HH:MM")
      echo "$(date +%Y-%m-%d) $time_input"
      ;;
    "MM-DD HH:MM")
      echo "$current_year-$time_input"
      ;;
    "YYYY-MM-DD HH:MM")
      echo "$time_input"
      ;;
  esac
}

# Past date validation function
function validate_future_datetime() {
  local normalized_datetime="$1"
  local original_format="$2"
  local target_timestamp
  local current_timestamp
  current_timestamp=$(date +%s)

  # Only validate future dates for new formats
  if [[ "$original_format" != "HH:MM" ]] ; then
    if date --version &> /dev/null ; then
      target_timestamp=$(date -d "$normalized_datetime" +%s 2>/dev/null || return 1)
    else
      target_timestamp=$(date -j -f "%Y-%m-%d %H:%M" "$normalized_datetime" +%s 2>/dev/null || return 1)
    fi

    if [[ $target_timestamp -le $current_timestamp ]] ; then
      echo "Error: Specified date/time is in the past: $normalized_datetime" >&2
      return 1
    fi
  fi

  return 0
}

# Unified date parsing with new format support
format=$(detect_time_format "$time")
if [[ $format == "INVALID" ]] ; then
  echo "Error: Invalid time format. Use HH:MM, MM-DD HH:MM, or YYYY-MM-DD HH:MM"
  exit 1
fi

normalized_datetime=$(normalize_datetime "$time" "$format")
if ! validate_future_datetime "$normalized_datetime" "$format" ; then
  exit 1
fi

# Unified date parsing for both GNU and BSD
if date --version >/dev/null 2>&1 ; then
  if ! target=$(date -d "$normalized_datetime" +%s 2>/dev/null) ; then
    echo "Error: Invalid date/time format"
    exit 1
  fi
else
  if ! target=$(date -j -f "%Y-%m-%d %H:%M" "$normalized_datetime" +%s 2>/dev/null) ; then
    echo "Error: Invalid date/time format"
    exit 1
  fi
fi

# Only add 24 hours for HH:MM format when time is in the past
if [[ $format == "HH:MM" && $target -le $now ]] ; then
  target=$((target + 86400))
fi

seconds=$((target - now))
duration=$(format_duration "$seconds")

echo "Notification scheduled: $time ($duration)"
echo "Title: $title"
echo "Message: $message"

# Start background process and capture PID
{
  sleep $seconds
  notify "$title" "$message" "$sound"
} &

job_pid=$!
echo "Process ID: $job_pid"

# https://github.com/aiya000/bash-toys
#
# The MIT License (MIT)
#
# Copyright (c) 2025- aiya000
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
