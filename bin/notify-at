#!/bin/bash

# Sends notification at specified time with flexible date formats
#
# Requirements:
# - ./notify
#
# Supported time formats:
# - HH:MM                - Time today (if past, then tomorrow)
# - MM-DD HH:MM          - Month-day-time (must be future)
# - YYYY-MM-DD HH:MM     - Year-month-day-time (must be future)
#
# ```shell-session
# $ notify-at 12:00 "Meeting" "Team meeting"                    # Today at 12:00
# $ notify-at "01-15 09:00" "Reminder" "New year meeting"       # January 15 at 09:00
# $ notify-at "2027-01-15 09:00" "Reminder" "Future meeting"    # Future date
# ```
#
# See also `$ notify-at --help`

set -e

function show_help() {
  cat << 'EOF'
notify-at - Sends notification at specified time with flexible date formats

Usage:
  notify-at TIME title message [sound]
  notify-at --help

Arguments:
  TIME      Time in one of the supported formats
  title     Notification title
  message   Notification message
  sound     Optional sound file (default: configured sound)

TIME formats:
  HH:MM                - Time today (if past, then tomorrow)
  MM-DD HH:MM          - Month-day-time (must be future)
  YYYY-MM-DD HH:MM     - Year-month-day-time (must be future)

Examples:
  notify-at 13:30 'Reminder' 'Meeting time'
  notify-at '01-15 09:00' 'Reminder' 'New year meeting'
  notify-at '2027-01-15 09:00' 'Reminder' 'Future meeting'
EOF
}

[[ $1 == --help ]] && show_help && exit 0

if [[ $# -lt 3 ]] ; then
  echo "Usage: $0 TIME title message [sound]"
  echo "TIME formats:"
  echo "  HH:MM                - Time today (if past, then tomorrow)"
  echo "  MM-DD HH:MM          - Month-day-time (must be future)"
  echo "  YYYY-MM-DD HH:MM     - Year-month-day-time (must be future)"
  echo "Examples:"
  echo "  $0 13:30 'Reminder' 'Meeting time'"
  echo "  $0 '01-15 09:00' 'Reminder' 'New year meeting'"
  echo "  $0 '2027-01-15 09:00' 'Reminder' 'Future meeting'"
  exit 1
fi

time="$1"
title="$2"
message="$3"
sound="${4:-${BASH_TOYS_NOTIFY_AT_DEFAULT_SOUND:-default}}"
now=$(date +%s)

# Format detection function
function detect_time_format() {
  local time_input="$1"

  if [[ $time_input =~ ^[0-9]{4}-[0-9]{2}-[0-9]{2}[[:space:]][0-9]{2}:[0-9]{2}$ ]] ; then
    echo "YYYY-MM-DD HH:MM"
  elif [[ $time_input =~ ^[0-9]{2}-[0-9]{2}[[:space:]][0-9]{2}:[0-9]{2}$ ]] ; then
    echo "MM-DD HH:MM"
  elif [[ $time_input =~ ^[0-9]{2}:[0-9]{2}$ ]] ; then
    echo "HH:MM"
  else
    echo "INVALID"
  fi
}

# Date normalization function
function normalize_datetime() {
  local time_input="$1"
  local format="$2"
  local current_year=$(date +%Y)

  case "$format" in
    "HH:MM")
      echo "$(date +%Y-%m-%d) $time_input"
      ;;
    "MM-DD HH:MM")
      echo "$current_year-$time_input"
      ;;
    "YYYY-MM-DD HH:MM")
      echo "$time_input"
      ;;
  esac
}

# Past date validation function
function validate_future_datetime() {
  local normalized_datetime="$1"
  local original_format="$2"
  local current_timestamp=$(date +%s)
  local target_timestamp

  # Only validate future dates for new formats
  if [[ "$original_format" != "HH:MM" ]] ; then
    if date --version &> /dev/null ; then
      target_timestamp=$(date -d "$normalized_datetime" +%s 2>/dev/null || return 1)
    else
      target_timestamp=$(date -j -f "%Y-%m-%d %H:%M" "$normalized_datetime" +%s 2>/dev/null || return 1)
    fi

    if [[ $target_timestamp -le $current_timestamp ]] ; then
      echo "Error: Specified date/time is in the past: $normalized_datetime" >&2
      return 1
    fi
  fi

  return 0
}

# Unified date parsing with new format support
format=$(detect_time_format "$time")
if [[ "$format" == "INVALID" ]] ; then
  echo "Error: Invalid time format. Use HH:MM, MM-DD HH:MM, or YYYY-MM-DD HH:MM"
  exit 1
fi

normalized_datetime=$(normalize_datetime "$time" "$format")
if ! validate_future_datetime "$normalized_datetime" "$format" ; then
  exit 1
fi

# Unified date parsing for both GNU and BSD
if date --version >/dev/null 2>&1 ; then
  if ! target=$(date -d "$normalized_datetime" +%s 2>/dev/null) ; then
    echo "Error: Invalid date/time format"
    exit 1
  fi
else
  if ! target=$(date -j -f "%Y-%m-%d %H:%M" "$normalized_datetime" +%s 2>/dev/null) ; then
    echo "Error: Invalid date/time format"
    exit 1
  fi
fi

# Only add 24 hours for HH:MM format when time is in the past
if [[ "$format" == "HH:MM" && $target -le $now ]] ; then
  target=$((target + 86400))
fi

seconds=$((target - now))
minutes=$((seconds / 60))

echo "Notification scheduled: $time ($minutes minutes later)"
echo "Title: $title"
echo "Message: $message"

(
  sleep $seconds
  notify "$title" "$message" "$sound"
) &

echo "Process ID: $!"

# https://github.com/aiya000/bash-toys
#
# The MIT License (MIT)
#
# Copyright (c) 2025- aiya000
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
