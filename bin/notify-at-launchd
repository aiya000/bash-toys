#!/bin/bash

# Sends notification at specified time using launchd (macOS only)
#
# NOTE:
# This script is intended to be called indirectly from `./notify-at`.
# If called directly, discrepancies may occur with the command name in the help output.
# Please consider implementing an alias or similar workaround.
#
# NOTE:
# Use `./notify-at-at` instead if using Linux or WSL (not macOS).
#
# Requirements:
# - ./notify (for local notifications)
# - ./notify-ntfy (for mobile notifications)
#
# Supported time formats:
# - HH:MM                - Time today (if past, then tomorrow)
# - MM-DD HH:MM          - Month-day-time (must be future)
# - YYYY-MM-DD HH:MM     - Year-month-day-time (must be future)
#
# ```shell-session
# $ notify-at-launchd 12:00 "Meeting" "Team meeting"                    # Today at 12:00
# $ notify-at-launchd "01-15 09:00" "Reminder" "New year meeting"       # January 15 at 09:00
# $ notify-at-launchd "2027-01-15 09:00" "Reminder" "Future meeting"    # Future date
# $ notify-at-launchd 12:00 "Meeting" "Team meeting" --mobile           # Mobile only
# $ notify-at-launchd 12:00 "Meeting" "Team meeting" --mobile --local   # Both
# ```
#
# See also `$ notify-at-launchd --help`

set -e

LAUNCHD_PREFIX="com.bash-toys.notify-at"
LAUNCHD_DIR="$HOME/Library/LaunchAgents"

function show_help() {
  cat << 'EOF'
notify-at - Sends notification at specified time using launchd (macOS version)

Usage:
  notify-at [options] TIME title message [sound]
  notify-at -l | --list
  notify-at -c JOB_ID [-c JOB_ID ...] | --cancel JOB_ID [--cancel JOB_ID ...]
  notify-at --help

Arguments:
  TIME      Time in one of the supported formats
  title     Notification title
  message   Notification message
  sound     Optional sound file (default: configured sound, only for --local)
  JOB_ID    Job ID of scheduled job to cancel (from 'notify-at -l')

Options:
  --mobile              Send notification to mobile via ntfy.sh
  --local               Send notification to local desktop (default if no options specified)
  -l, --list            List all scheduled jobs
  -c, --cancel JOB_ID   Cancel scheduled job by Job ID
  --help                Show this help message

Note: If --mobile is specified without --local, only mobile notification is sent.
      If neither is specified, --local is assumed.

Environment Variables:
  BASH_TOYS_NTFY_TOPIC    Required when using --mobile. Your ntfy.sh topic name.

TIME formats:
  HH:MM                - Time today (if past, then tomorrow)
  MM-DD HH:MM          - Month-day-time (must be future)
  YYYY-MM-DD HH:MM     - Year-month-day-time (must be future)

Examples:
  notify-at 13:30 'Reminder' 'Meeting time'
  notify-at '01-15 09:00' 'Reminder' 'New year meeting'
  notify-at '2027-01-15 09:00' 'Reminder' 'Future meeting'
  notify-at 13:30 'Reminder' 'Meeting time' --mobile
  notify-at 13:30 'Reminder' 'Meeting time' --mobile --local

Job management:
  notify-at -l                    # List scheduled jobs
  notify-at --cancel abc123       # Cancel job with Job ID abc123

Note:
  This tool uses launchd for reliable scheduling on macOS.
  Jobs are stored in ~/Library/LaunchAgents/
EOF
}

# Generate unique job ID
function generate_job_id() {
  date +%s%N | shasum | head -c 8
}

# Get plist path for a job ID
function get_plist_path() {
  local job_id="$1"
  echo "$LAUNCHD_DIR/$LAUNCHD_PREFIX.$job_id.plist"
}

# Get label for a job ID
function get_label() {
  local job_id="$1"
  echo "$LAUNCHD_PREFIX.$job_id"
}

# Schedule a job using launchd
# Arguments: $1=target_timestamp $2=title $3=message $4=sound $5=local_mode $6=mobile_mode $7=notify_ntfy_cmd
# Output: job_id on success
function schedule_launchd_job() {
  local target_timestamp="$1"
  local title="$2"
  local message="$3"
  local sound="$4"
  local local_mode="$5"
  local mobile_mode="$6"
  local notify_ntfy_cmd="$7"

  local now
  now=$(date +%s)

  if [[ $target_timestamp -lt $now ]] ; then
    echo "Error: Target time is in the past" >&2
    return 1
  fi

  local job_id
  job_id=$(generate_job_id)
  local plist_path
  plist_path=$(get_plist_path "$job_id")
  local label
  label=$(get_label "$job_id")

  # Ensure LaunchAgents directory exists
  mkdir -p "$LAUNCHD_DIR"

  # Extract date components for StartCalendarInterval
  local target_year target_month target_day target_hour target_minute
  target_year=$(date -r "$target_timestamp" +%Y)
  target_month=$(date -r "$target_timestamp" +%-m)  # Without leading zero
  target_day=$(date -r "$target_timestamp" +%-d)    # Without leading zero
  target_hour=$(date -r "$target_timestamp" +%-H)   # Without leading zero
  target_minute=$(date -r "$target_timestamp" +%-M) # Without leading zero

  # Create a wrapper script that checks the year and executes the notification
  # This is needed because StartCalendarInterval doesn't support Year field
  local script_path="/tmp/notify-at-$job_id.sh"

  # Escape special characters for shell script
  local shell_escaped_title="${title//\\/\\\\}"
  shell_escaped_title="${shell_escaped_title//\"/\\\"}"
  shell_escaped_title="${shell_escaped_title//\$/\\\$}"
  local shell_escaped_message="${message//\\/\\\\}"
  shell_escaped_message="${shell_escaped_message//\"/\\\"}"
  shell_escaped_message="${shell_escaped_message//\$/\\\$}"

  # Build the wrapper script
  cat > "$script_path" << 'SCRIPT_HEADER'
#!/bin/bash
set -e

target_year="TARGET_YEAR_PLACEHOLDER"
target_timestamp="TARGET_TIMESTAMP_PLACEHOLDER"
plist_path="PLIST_PATH_PLACEHOLDER"
label="LABEL_PLACEHOLDER"
script_path="SCRIPT_PATH_PLACEHOLDER"

# Check if current year matches target year
current_year=$(date +%Y)
if [[ "$current_year" != "$target_year" ]] ; then
  exit 0
fi

# Check if we're within 2 minutes of target time (handles slight delays)
current_timestamp=$(date +%s)
time_diff=$((current_timestamp - target_timestamp))
if [[ $time_diff -lt -120 || $time_diff -gt 120 ]] ; then
  # Not the right time, exit silently
  exit 0
fi

SCRIPT_HEADER

  # Replace placeholders
  sed -i '' "s|TARGET_YEAR_PLACEHOLDER|$target_year|g" "$script_path"
  sed -i '' "s|TARGET_TIMESTAMP_PLACEHOLDER|$target_timestamp|g" "$script_path"
  sed -i '' "s|PLIST_PATH_PLACEHOLDER|$plist_path|g" "$script_path"
  sed -i '' "s|LABEL_PLACEHOLDER|$label|g" "$script_path"
  sed -i '' "s|SCRIPT_PATH_PLACEHOLDER|$script_path|g" "$script_path"

  # Add local notification if requested
  if [[ "$local_mode" == true ]] ; then
    cat >> "$script_path" << EOF
# Send local notification
osascript -e 'display notification "$shell_escaped_message" with title "$shell_escaped_title"'
EOF

    # Add sound playback if specified
    if [[ -n "$sound" && "$sound" != "default" ]] ; then
      cat >> "$script_path" << EOF
afplay '$sound' &
EOF
    fi
  fi

  # Add mobile notification if requested
  if [[ "$mobile_mode" == true ]] ; then
    # Escape for shell command
    local ntfy_escaped_title="${title//\'/\'\\\'\'}"
    local ntfy_escaped_message="${message//\'/\'\\\'\'}"
    cat >> "$script_path" << EOF
# Send mobile notification
export BASH_TOYS_NTFY_TOPIC='$BASH_TOYS_NTFY_TOPIC'
'$notify_ntfy_cmd' '$ntfy_escaped_title' '$ntfy_escaped_message'
EOF
  fi

  # Add cleanup
  cat >> "$script_path" << 'EOF'
# Cleanup: unload and remove plist, remove script
launchctl unload "$plist_path" 2>/dev/null || true
rm -f "$plist_path"
rm -f "$script_path"
EOF

  chmod +x "$script_path"

  # Create plist file with StartCalendarInterval
  cat > "$plist_path" << EOF
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
    <key>Label</key>
    <string>$label</string>
    <key>ProgramArguments</key>
    <array>
        <string>/bin/bash</string>
        <string>$script_path</string>
    </array>
    <key>StartCalendarInterval</key>
    <dict>
        <key>Month</key>
        <integer>$target_month</integer>
        <key>Day</key>
        <integer>$target_day</integer>
        <key>Hour</key>
        <integer>$target_hour</integer>
        <key>Minute</key>
        <integer>$target_minute</integer>
    </dict>
    <key>StandardOutPath</key>
    <string>/tmp/notify-at-$job_id.log</string>
    <key>StandardErrorPath</key>
    <string>/tmp/notify-at-$job_id.log</string>
</dict>
</plist>
EOF

  # Store metadata as extended attributes for job listing
  xattr -w "$LAUNCHD_PREFIX.title" "$title" "$plist_path" 2>/dev/null || true
  xattr -w "$LAUNCHD_PREFIX.message" "$message" "$plist_path" 2>/dev/null || true
  xattr -w "$LAUNCHD_PREFIX.target" "$target_timestamp" "$plist_path" 2>/dev/null || true

  # Store target mode (local,mobile)
  local target_modes=()
  [[ "$local_mode" == true ]] && target_modes+=("local")
  [[ "$mobile_mode" == true ]] && target_modes+=("mobile")
  local target_mode_str
  IFS=',' ; target_mode_str="${target_modes[*]}" ; IFS=' '
  xattr -w "$LAUNCHD_PREFIX.mode" "$target_mode_str" "$plist_path" 2>/dev/null || true

  # Load the job
  if launchctl load "$plist_path" 2>/dev/null ; then
    echo "$job_id"
  else
    rm -f "$plist_path"
    rm -f "$script_path"
    echo "Error: Failed to load launchd job" >&2
    return 1
  fi
}

# Job management functions
function list_jobs() {
  local found=0

  # Check for plist files
  if [[ ! -d "$LAUNCHD_DIR" ]] ; then
    echo "No scheduled jobs found."
    return 0
  fi

  # Array to store "timestamp|job_line" for sorting
  local job_entries=()

  for plist in "$LAUNCHD_DIR/$LAUNCHD_PREFIX."*.plist ; do
    [[ -f "$plist" ]] || continue

    # Extract job ID from filename
    local filename
    filename=$(basename "$plist")
    local job_id="${filename#$LAUNCHD_PREFIX.}"
    job_id="${job_id%.plist}"

    # Get metadata from extended attributes
    local title message target_timestamp target_mode
    title=$(xattr -p "$LAUNCHD_PREFIX.title" "$plist" 2>/dev/null || echo "N/A")
    message=$(xattr -p "$LAUNCHD_PREFIX.message" "$plist" 2>/dev/null || echo "N/A")
    target_timestamp=$(xattr -p "$LAUNCHD_PREFIX.target" "$plist" 2>/dev/null || echo "0")
    target_mode=$(xattr -p "$LAUNCHD_PREFIX.mode" "$plist" 2>/dev/null || echo "local")

    # Format target time (YYYY-MM-DD HH:MM)
    local time_str="N/A"
    if [[ "$target_timestamp" != "0" ]] ; then
      time_str=$(date -r "$target_timestamp" +"%Y-%m-%d %H:%M" 2>/dev/null || echo "N/A")
    fi

    local job_line
    job_line=$(printf "%-10s %-18s %-14s %-15s %s" "$job_id" "$time_str" "$target_mode" "${title:0:15}" "${message:0:40}")
    # Store with timestamp prefix for sorting
    job_entries+=("${target_timestamp}|${job_line}")
    found=1
  done

  if [[ $found -eq 0 ]] ; then
    echo "No scheduled jobs found."
    return 0
  fi

  # Display header and jobs
  printf "%-10s %-18s %-14s %-15s %s\n" "JOB_ID" "DATETIME" "TARGET" "TITLE" "MESSAGE"
  printf "%-10s %-18s %-14s %-15s %s\n" "--------" "----------------" "------" "-----" "-------"

  # Sort by timestamp and display (remove timestamp prefix)
  printf '%s\n' "${job_entries[@]}" | sort -t'|' -k1 -n | cut -d'|' -f2-
}

function cancel_job() {
  local target_job_id="$1"

  if [[ -z "$target_job_id" ]] ; then
    echo "Error: Job ID required for cancel operation"
    echo "Usage: $0 -c JOB_ID [-c JOB_ID ...]"
    echo "       $0 --cancel JOB_ID [--cancel JOB_ID ...]"
    return 1
  fi

  local plist_path
  plist_path=$(get_plist_path "$target_job_id")
  local label
  label=$(get_label "$target_job_id")

  if [[ ! -f "$plist_path" ]] ; then
    echo "Error: Job with ID $target_job_id not found"
    return 1
  fi

  # Unload and remove plist, script, and log files
  launchctl unload "$plist_path" 2>/dev/null || true
  rm -f "$plist_path"
  rm -f "/tmp/notify-at-$target_job_id.sh"
  rm -f "/tmp/notify-at-$target_job_id.log"

  echo "Job $target_job_id cancelled successfully"
}

# Option parsing
[[ $1 == --help ]] && show_help && exit 0

if [[ $1 == "-l" || $1 == "--list" ]] ; then
  list_jobs
  exit 0
fi

# Handle multiple -c/--cancel options
if [[ $1 == "-c" || $1 == "--cancel" ]] ; then
  job_ids=()
  exit_code=0

  # Collect all job IDs from -c/--cancel options
  while [[ $# -gt 0 ]] ; do
    case "$1" in
      -c|--cancel)
        if [[ -n "$2" && ! "$2" =~ ^- ]] ; then
          job_ids+=("$2")
          shift 2
        else
          echo "Error: -c/--cancel requires a job ID argument"
          exit 1
        fi
        ;;
      *)
        echo "Error: Unexpected argument: $1"
        exit 1
        ;;
    esac
  done

  # Cancel all collected jobs
  for job_id in "${job_ids[@]}" ; do
    if ! cancel_job "$job_id" ; then
      exit_code=1
    fi
  done

  exit $exit_code
fi

# Parse arguments - extract --mobile and --local options
mobile_mode=false
local_mode=false
positional_args=()

for arg in "$@" ; do
  case "$arg" in
    --mobile)
      mobile_mode=true
      ;;
    --local)
      local_mode=true
      ;;
    *)
      positional_args+=("$arg")
      ;;
  esac
done

# Default to local mode if neither is specified
if [[ "$mobile_mode" == false && "$local_mode" == false ]] ; then
  local_mode=true
fi

# Validate ntfy topic when mobile mode is requested
if [[ "$mobile_mode" == true && -z "${BASH_TOYS_NTFY_TOPIC:-}" ]] ; then
  echo "Error: BASH_TOYS_NTFY_TOPIC environment variable is required for --mobile option" >&2
  exit 1
fi

if [[ ${#positional_args[@]} -lt 3 ]] ; then
  show_help
  exit 1
fi

time="${positional_args[0]}"
title="${positional_args[1]}"
message="${positional_args[2]}"
sound="${positional_args[3]:-${BASH_TOYS_NOTIFY_AT_DEFAULT_SOUND:-default}}"
now=$(date +%s)

# Format seconds to human-readable duration
# e.g., "1 day 2 hours 30 minutes later"
function format_duration() {
  local total_seconds="$1"
  local parts=()

  local days=$((total_seconds / 86400))
  local remaining=$((total_seconds % 86400))
  local hours=$((remaining / 3600))
  remaining=$((remaining % 3600))
  local minutes=$((remaining / 60))

  if [[ $days -gt 0 ]] ; then
    if [[ $days -eq 1 ]] ; then
      parts+=("1 day")
    else
      parts+=("$days days")
    fi
  fi

  if [[ $hours -gt 0 ]] ; then
    if [[ $hours -eq 1 ]] ; then
      parts+=("1 hour")
    else
      parts+=("$hours hours")
    fi
  fi

  if [[ $minutes -gt 0 || ${#parts[@]} -eq 0 ]] ; then
    if [[ $minutes -eq 1 ]] ; then
      parts+=("1 minute")
    else
      parts+=("$minutes minutes")
    fi
  fi

  local result="${parts[0]}"
  for ((i=1; i<${#parts[@]}; i++)) ; do
    result="$result ${parts[$i]}"
  done

  echo "$result later"
}

# Format detection function
function detect_time_format() {
  local time_input="$1"

  if [[ $time_input =~ ^[0-9]{4}-[0-9]{2}-[0-9]{2}[[:space:]][0-9]{2}:[0-9]{2}$ ]] ; then
    echo "YYYY-MM-DD HH:MM"
  elif [[ $time_input =~ ^[0-9]{2}-[0-9]{2}[[:space:]][0-9]{2}:[0-9]{2}$ ]] ; then
    echo "MM-DD HH:MM"
  elif [[ $time_input =~ ^[0-9]{2}:[0-9]{2}$ ]] ; then
    echo "HH:MM"
  else
    echo "INVALID"
  fi
}

# Date normalization function
function normalize_datetime() {
  local time_input="$1"
  local format="$2"

  local current_year
  current_year=$(date +%Y)

  case "$format" in
    "HH:MM")
      echo "$(date +%Y-%m-%d) $time_input"
      ;;
    "MM-DD HH:MM")
      echo "$current_year-$time_input"
      ;;
    "YYYY-MM-DD HH:MM")
      echo "$time_input"
      ;;
  esac
}

# Past date validation function
function validate_future_datetime() {
  local normalized_datetime="$1"
  local original_format="$2"
  local target_timestamp
  local current_timestamp
  current_timestamp=$(date +%s)

  # Only validate future dates for new formats
  if [[ "$original_format" != "HH:MM" ]] ; then
    target_timestamp=$(date -j -f "%Y-%m-%d %H:%M" "$normalized_datetime" +%s 2>/dev/null || return 1)

    if [[ $target_timestamp -le $current_timestamp ]] ; then
      echo "Error: Specified date/time is in the past: $normalized_datetime" >&2
      return 1
    fi
  fi

  return 0
}

# Unified date parsing with new format support
format=$(detect_time_format "$time")
if [[ $format == "INVALID" ]] ; then
  echo "Error: Invalid time format. Use HH:MM, MM-DD HH:MM, or YYYY-MM-DD HH:MM"
  exit 1
fi

normalized_datetime=$(normalize_datetime "$time" "$format")
if ! validate_future_datetime "$normalized_datetime" "$format" ; then
  exit 1
fi

# BSD date parsing (macOS)
if ! target=$(date -j -f "%Y-%m-%d %H:%M" "$normalized_datetime" +%s 2>/dev/null) ; then
  echo "Error: Invalid date/time format"
  exit 1
fi

# Only add 24 hours for HH:MM format when time is in the past
# Use -lt (not -le) because target has seconds=00, so target==now means "this minute"
if [[ $format == "HH:MM" && $target -lt $now ]] ; then
  target=$((target + 86400))
fi

seconds=$((target - now))
duration=$(format_duration "$seconds")

echo "Notification scheduled: $time ($duration)"
echo "Title: $title"
echo "Message: $message"
if [[ "$local_mode" == true ]] ; then
  echo "Target: local"
fi
if [[ "$mobile_mode" == true ]] ; then
  echo "Target: mobile (ntfy.sh)"
fi

# Get the full path to notify-ntfy command
script_dir="$(cd -- "$(dirname -- "${BASH_SOURCE:-$0}")" && pwd)"
notify_ntfy_cmd="$script_dir/notify-ntfy"

# Schedule using launchd
job_id=$(schedule_launchd_job "$target" "$title" "$message" "$sound" "$local_mode" "$mobile_mode" "$notify_ntfy_cmd")

if [[ -n "$job_id" ]] ; then
  echo "Job ID: $job_id"
else
  echo "Error: Failed to schedule notification"
  exit 1
fi

# https://github.com/aiya000/bash-toys
#
# The MIT License (MIT)
#
# Copyright (c) 2025- aiya000
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
